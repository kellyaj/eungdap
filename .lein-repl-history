(println (-> "./public/image.gif" java.io.FileInputStream. .read))
(byte-array (-> "./public/image.gif" java.io.FileInputStream. .read))
(ary 1 2 3 4)
(into [] 1 2 3 4)
(byte-array (-> "./public/image.gif" java.io.FileInputStream. .read))
(byte-array 15)
(byte-array (-> "./public/image.gif" java.io.FileInputStream. .read))
(byte-array 1)
(prn (-> "./public/image.gif" java.io.FileInputStream. .read))
(byte-array (-> "./public/image.gif" java.io.FileInputStream. .read ((-> "./public/image.gif" java.io.FileInputStream. .read))))
(byte-array (-> "./public/image.gif" java.io.FileInputStream. .read 71))
(byte-array (-> "./public/image.gif" java.io.FileInputStream. .read (71)))
(byte-array (-> "./public/image.gif" java.io.FileInputStream. .read 71)))
(byte-array (-> "./public/image.gif" java.io.FileInputStream. .read 71))
(prn (-> "./public/image.gif" java.io.FileInputStream. .read))
(-> "./public/image.gif" java.io.FileInputStream. .getChannel)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.io.FileChannel. .transferTo)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.FileChannel. .transferTo)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel. .transferTo)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel. .transferTo("./public/file1"))
(-> (-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel. .transferTo) java.nio.channels.FileChannel)
(-> "./public/image.gif" java.io.FileInputStream. .getChannel)
(java.nio.channels.FileChannel.)
(java.nio.channels.FileChannel. "c")
(java.nio.channels.FileChannel. 13)
(-> "./public/image.gif" java.io.FileInputStream. .getChannel)
(java.io.FileInputstream. .getChannel "./public/image.gif")
(java.io.FileInputStream. .getChannel "./public/image.gif")
(java.io.FileInputStream. "./public/image.gif" .getChannel)
(-> "./public/image.gif" java.io.FileInputStream. .getChannel)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.TStsdgdg)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.TStsdgdg .getSg)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel))
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel))
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel .transferto)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel .transferTo)
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel. .transferTo)
(what-is "hdh")
(-> (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel. .transferTo)
(-> "./public/image.gif" java.io.FileInputStream. .getChannel)
(-> *out* (-> "./public/image.gif" java.io.FileInputStream. .getChannel) java.nio.channels.FileChannel. .transferTo)
(-> *out* (-> "./public/image.gif" java.io.FileInputStream. .getChannel) .transferTo)
(-> *out* (-> (-> "./public/image.gif" java.io.File. .getCanonicalFile) java.io.FileInputStream. .getChannel) .transferTo)
(-> *out* (-> (-> "./public/image.gif" java.io.File. .getAbsoluteFile) java.io.FileInputStream. .getChannel) .transferTo)
(-> d (-> (-> "./public/image.gif" java.io.File. .getAbsoluteFile) java.io.FileInputStream. .getChannel) .transferTo)
(-> fn[] (-> (-> "./public/image.gif" java.io.File. .getAbsoluteFile) java.io.FileInputStream. .getChannel) .transferTo)
(FileInputStream. fname)
*out*
(-> "test" *out* .write)
(*out* .write)
(*out*. .write)
(*out* .write "test")
(.write "test")
(.write *out* "test")
*out*
(.getChannel)
(.getChannel out)
(.getChannel *out*)
(let [*out* java.io.SocketOutputStream] (.getChannel *out*))
(:use server.socket) (let [*out* java.io.SocketOutputStream] (.getChannel *out*))
(let [*out* java.io.SocketOutputStream] (.getChannel *out*))
(ByteArrayInputStream.
)
(import '[java.io.*])
(ByteArrayInputStream.)
(-> (.getBytes "abcde") .write ByteArrayOutputStream. ))
(-> (.getBytes "abcde") .write ByteArrayOutputStream. )
(.getBytes "abc")
(require 'java.io.ByteArrayOutputStream)
(require '[java.io ByteArrayOutputStream])
(require '[java.io.ByteArrayOutputStream])
(require '[java.io.OutputStream])
(.getBytes "abc")
(require '[java.io.ByteArrayOutputStream])
(import '[java.io.ByteArrayOutputStream])
(import '[java.io.ByteArrayOutputStream :as baos])
(import '[java.io.ByteArrayOutputStream])
(-> (.getBytes "abc") (ByteArrayOutputStream.) .write)
(import '[java.io.ByteArrayOutputStream]) (-> (.getBytes "abc") (ByteArrayOutputStream.) .write)
(doseq [x ["a" "b" "c"]] (print x))
(let [x []] (doseq [y ["a" "b" "c"]] (into x y )) (println (first x)))
(let [x []] (into x "1") (println (first x)))
(let [x []] (into x "1") (println (peek x)))
(slurp ./public/index.html)
(slurp "./public/index.html")
(.getBytes (slurp "./public/index.html"))
(.getBytes (slurp "./public/404.html"))
(slurp "./public/404.html")
(.getBytes "abcd")
(.length (.getBytes "abcd"))
(.size (.getBytes "abcd"))
(.getBytes "abcd" "UTF-8"))
(.getBytes "abcd" "UTF-8")
(.length (.getBytes "abcd" "UTF-8"))
(.length (.getBytes "UTF-8" "abcde"))
(.getBytes "UTF-8" "abcde")
(.getBytes "abcde")
(.getBytes "abcde" "UTF-8")
(.length (.getBytes "abcde" "UTF-8"))
(.length (.getBytes "abcde"( "UTF-8")))
(.length (.getBytes "abcde" "UTF-8"))
(.getClass (.getBytes "abcde" "UTF-8"))
(.getClass (.getBytes "abcde"))
(.toString (.getBytes "abcde"))
(.clone (.getBytes "abcde"))
(.getClass (.getBytes "abcde"))
(.alength (.getBytes "abcde" "UTF-8"))
(alength (.getBytes "abcde" "UTF-8"))
(byte-array "abc")
(byte-array (.getBytes "abc"))
(byte-array (+ (.getBytes "edf") (.getBytes "abc")))
(byte-array (concat (.getBytes "edf") (.getBytes "abc")))
(println (-> "./public/image.gif" java.io.FileInputStream. .read))
(let [ba (.getBytes "abc")] (apply str (map char ba)))
(clojure.string/join "" (map char (concat (.getBytes "Hello") (.getBytes "World!"))))
(defn get-file-extension [request]                                                    |  8 (defn get-file-name [request]
  8   (if (not= 1 (count (clojure.string/split request #"\.")))                           |  9   (if (= request "GET /")
  9     (if (not= true (-> (peek (clojure.string/split request #"\.")) java.io.File. .isDi| 10       "public"
    rectory))                                                                             | 11       (str (peek (clojure.string/split request
 10       (if (= "." (re-find #"\." request))                                             |     #"/")))))
 11         (peek (clojure.string/split request #"\."))                                   | 12 
 12         "none"))))
(= 1 0)
(= true (= 1 0))
(= true (= 1 0) (= 1 1)))
(= true (= 1 0) (= 1 1))
(= true (= 1 1) (= 1 1))
(-> "./public/index.html" java.io.File. .isFile)
(-> "./public/file1" java.io.File. .isFile)
(clojure.string/join "" (map char (concat (.getBytes "Hello") (.getBytes "World!"))))
(not= 1 (count (clojure.string/split "GET /pretzels" #"\.")))
(not= 1 (count (clojure.string/split "GET /pretzels.html" #"\.")))
(not= 1 (count (clojure.string/split "GET /pretzels" #"\.")))
(not= 1 (count (clojure.string/split "/pretzels" #"\.")))
(not= 1 (count (clojure.string/split "pretzels" #"\.")))
(not= 1 (count (clojure.string/split "/pretzels" #"\.")))
(not= 1 (count (clojure.string/split "GET /pretzels.html" #"\.")))
(not= 1 (count (clojure.string/split "GET /pretzels" #"\.")))
(not= 1 (count (clojure.string/split "/pretzels" #"\.")))
(not= 1 (count (clojure.string/split "GET /pretzels" #"\.")))
(peek (clojure.string/split "GET /pretzels" #"\."))
(peek (clojure.string/split "GET /pretzels.html" #"\."))
(peek (clojure.string/split "GET /pretzels.jpg" #"\."))
(peek (clojure.string/split "GET /pretzels.html" #"\."))
(peek (clojure.string/split "GET /pretzels.txt" #"\."))
(= "." (re-find #"\." "GET /pretzels"))
(= "." (re-find #"\." "GET /pretzels.html"))
(= "." (re-find #"\." "GET /pretzels"))
(false? "." (re-find #"\." "GET /pretzels"))
(not= "." (re-find #"\." "GET /pretzels"))
(clojure.string/split "GET /pretzels.txt" #"\.")
(clojure.string/split "GET /pretzels.txt" #"\/")
(clojure.string/split "GET /pretzels.txt" #"\ /")
(clojure.string/split "POST /pretzels.txt" #"\ /")
(clojure.string/split "PUT /pretzels.txt" #"\ /")
(clojure.string/split "PUT /pretzels.txt" #" /")
(.getBytes "abc")
(.length (.getBytes "abc"))
(count (.getBytes "abc"))
(byte-array (map byte [1 2 3]))
(byte-array (map byte "abc"))
(byte-array (map byte ["a" "b" "c"]))
(atom 49)
@
r
(def a (atom 49))
a
@a
(+ @a 1)
@a
(swap! a 4)
(swap! a (+ a 1))
(swap! a inc)
@a
a
(reset! a 111)
a
@a
(swap! a inc)
(reset! a "ff"
)
a
)
(def apple-price (atom 1))
apple-price
@apple-price
(!swap @apple-price 2)
(!swap apple-price 2)
(swap! apple-price inc)
(def my-name (atom "joe"))
@my-name
(swap! my-name "sam")
my-name
@my-name
(defn change-name [name] (def my-name (atom name)))
@my-name
(change-name "sam")
@my-name
my-name
@my-name
(def @guest (atom "billy"))
(def guest (atom "billy"))
@guest
guest
(swap! guest "timmy")
(reset! guest "timmy")
guest
@guest
(defn post-data [data-name input] (def data-name (atom input)))
(post-data "test" "works?")
data-name
test
(post-data "qwert" "zxcv")
data-name
(post-data qwert "zxcv")
{"test" "qwert"}
"test"
"gggg
"
(hash-map "test" "qwert" "bob" "jam")
"test'
"
(def my-map (hash-map "test" "qwert" "bob" "jam"))
my-map
(get my-map "test")
(def other-map {})
(assoc other-map "bob" "jam")
other-map
(other-map)
(merge other-map "bob" "jam")
other-map
(defn add-other-map [key value] (let [new-map {}] (assoc other-map key value)))
(add-other-map "bob" "tom")
new-map
(add-other-map "qweeee" "tttzzcvv")
(def my-map (atom {"test" "qwerty"}))
mypmap
my-map
(get my-map "test")
(my-map
)
my-map
(get my-map)
(get "test" my-map)
my-map
@my-map
(get "test" @my-map)
(get @my-map "test")
(swap! @my-map "name" "joey")
(swap! @my-map conj "name" "joey")
(swap! my-map conj "name" "joey")
@my-map
(conj @my-map "yep" "do")
(merge @my-map {"frank" "enstein"})
@my-map
(reset! my-map (merge @my-map {"frank" "enstein"}))
@my-map
(find @my-map "enstein")
(find @my-map "frank")
(get @my-map "frank")
(get @my-map "enstein")
(key @my-map "enstein")
(map key @my-map "enstein")
(map key @my-map)
@my-map
(get @my-map "test")
(assoc @my-map "test" "zippy")
(dissoc @my-map "test")
@my-map
(swap! my-map dissoc "test")
@my-map
(get @my-map "frank")
@my-map
(reset! my-map (merge @my-map (hash-map "yupp" "yupp")))
(reset! my-map (merge my-map (hash-map "yupp" "yupp")))
(reset! my-map (merge @my-map (hash-map "yupp" "yupp")))
(reset! my-map (merge @my-map (hash-map "yupp" "yupg")))
(loop [stuff []] (into stuff "abc") (println stuff) (recur stuff))
(loop [stuff []] ( (println "abc") (recur (into stuff "abc")))
)
(loop [stuff []] ( (println "abc") (recur (into stuff "abc"))))
(loop [stuff []] ( (println "abc") (let [newstuff (into stuff "abc")] (recur newstuff))))
(loop [stuff []] (println "abc") (let [newstuff (into stuff "abc")] (recur newstuff))))
(loop [stuff []] (println "abc") (let [newstuff (into stuff "a")] (recur newstuff))))
(loop [stuff []] (println stuff) (let [newstuff (into stuff "a")] (recur newstuff))))
"GET /pretzels HTTP/1.1"
(clojure.string/split "GET /pretzels HTTP/1.1")
(clojure.string/split "GET /pretzels HTTP/1.1" #"\ ")
(first (clojure.string/split "GET /pretzels HTTP/1.1" #"\ "))
(hash-map :test (first (clojure.string/split "GET /pretzels HTTP/1.1" #"\ ")))
(hash-map :test (first (clojure.string/split "GET /pretzels HTTP/1.1" #"\ ")) :test1 (last (clojure.string/split "GET /pretzels HTTP/1.1" #"\ ")))
(hash-map :test (first (clojure.string/split "GET /pretzels HTTP/1.1" #"\ ")) :test1 (last (clojure.string/split "GET /pretzels HTTP/1.1" #"\ ")) :test2 (nth (clojure.string/split "GET /pretzels HTTP/1.1" #"\ ") 1))
(clojure.string/split "/pretzels.html" #"\.")
(clojure.string/split "/pretzels" #"\.")
(count (clojure.string/split "/pretzels" #"\."))
(last (clojure.string/split "/pretzels.html" #"\."))
fg
